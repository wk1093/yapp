#import std.math
#import std.io
#import <thread>

#import <glad/glad.h>
#import <GLFW/glfw3.h>


const int GRID_SIZE = 64*1; // Grid resolution (64x64)
const float DT = 0.1f; // Time step
const float DIFFUSION = 0.00001f; // Diffusion rate
const float VISCOSITY = 0.0001f; // Viscosity
const int WINDOW_SIZE = 64*4; // Window size in pixels
const float SCALE = (float)(WINDOW_SIZE) / GRID_SIZE; // Scale factor for rendering

const char* VERTEX_SHADER = R"(#version 430 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTex;

out vec2 TexCoord;

void main() {
    TexCoord = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
)";

const char* FRAGMENT_SHADER =R"(#version 430 core
out vec4 FragColor;

in vec2 TexCoord;
uniform sampler2D uSimData; // RGBA32F: r=density, g=u, b=v, a=unused

// HSV to RGB conversion in GLSL
vec3 hsv2rgb(float h, float s, float v) {
    float c = v * s;
    float x = c * (1.0 - abs(mod(h / 60.0, 2.0) - 1.0));
    float m = v - c;
    float r, g, b;
    if (h < 60.0)      { r = c; g = x; b = 0.0; }
    else if (h < 120.0){ r = x; g = c; b = 0.0; }
    else if (h < 180.0){ r = 0.0; g = c; b = x; }
    else if (h < 240.0){ r = 0.0; g = x; b = c; }
    else if (h < 300.0){ r = x; g = 0.0; b = c; }
    else               { r = c; g = 0.0; b = x; }
    return vec3(r + m, g + m, b + m);
}

void main() {
    vec4 sim = texture(uSimData, TexCoord);
    float d = sim.r;
    float u = sim.g;
    float v = sim.b;
    float speed = sqrt(u * u + v * v);
    d = min(d, 255.0);
    speed = min(speed, 10.0);

    // New visualization logic
    float angle = atan(v, u) * (180.0 / 3.14159265359); // angle in degrees
    float hue = mod(angle, 360.0);
    float saturation = 1.0; // Keep saturation high for vibrant colors
    float brightness = pow(min(d / 150.0, 1.0), 0.8); // Use power for better contrast

    vec3 rgb = hsv2rgb(hue, saturation, brightness);
    FragColor = vec4(rgb, 1.0);
}
)";

// Helper function to convert 2D grid indices to 1D array index
int IX(int x, int y) {
    x = math::max(0, math::min(x, GRID_SIZE - 1));
    y = math::max(0, math::min(y, GRID_SIZE - 1));
    return x + y * GRID_SIZE;
}

GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    int length = strlen(source);
    glShaderSource(shader, 1, &source, &length);
    glCompileShader(shader);

    // Check for errors
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        io::println(io::err, "Shader compilation failed: ", log);
    }

    return shader;
}

GLuint createShaderProgram(const char* vertexSrc, const char* fragmentSrc) {
    GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexSrc);
    GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentSrc);

    GLuint program = glCreateProgram();
    glAttachShader(program, vertShader);
    glAttachShader(program, fragShader);
    glLinkProgram(program);

    // Check for linking errors
    GLint success;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        char log[512];
        glGetProgramInfoLog(program, 512, nullptr, log);
        io::println(io::err, "Program linking failed: ", log);
    }

    glDeleteShader(vertShader);
    glDeleteShader(fragShader);

    return program;
}

// New helper function to build shader source with defines
str build_shader_source(const char* base_code, int grid_size) {
    str header = "#version 430 core\n";
    header += "#define GRID_SIZE " + std::to_string(grid_size) + "\n";
    return header + base_code;
}

const char* COMPUTE_ADD_FORCE_SHADER_SRC = R"(
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
// Use image2D for read-write access
layout(binding = 0, rgba32f) uniform image2D u_sim_tex;

uniform vec2 u_point;
uniform float u_radius;
uniform vec4 u_value; // .r=density, .g=velX, .b=velY

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    float dist = distance(vec2(coord), u_point);

    if (dist < u_radius) {
        vec4 old_data = imageLoad(u_sim_tex, coord);
        float falloff = 1.0 - dist / u_radius;
        imageStore(u_sim_tex, coord, old_data + u_value * falloff);
    }
}
)";

const char* COMPUTE_ADVECT_SHADER_SRC = R"(
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
// Use a sampler for interpolated reads
layout(binding = 0) uniform sampler2D u_read_tex;
// Use an image for writing
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

uniform float u_dt;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(coord) + 0.5) / float(GRID_SIZE);
    
    vec2 vel = texture(u_read_tex, uv).gb;
    // Trace back in time
    vec2 prev_uv = uv - (vel * u_dt / float(GRID_SIZE));
    
    // Read advected quantity from previous position
    vec4 advected_data = texture(u_read_tex, prev_uv);
    imageStore(u_write_tex, coord, advected_data);
}
)";

const char* COMPUTE_JACOBI_SHADER_SRC = R"(
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
// x: current iteration, b: constant term
layout(binding = 0) uniform sampler2D u_x_tex;
layout(binding = 1) uniform sampler2D u_b_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

uniform float u_alpha;
uniform float u_beta_reciprocal;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(coord) + 0.5) / float(GRID_SIZE);
    vec2 texel_size = vec2(1.0 / float(GRID_SIZE));

    // Sample neighbors
    vec4 x_l = texture(u_x_tex, uv - vec2(texel_size.x, 0));
    vec4 x_r = texture(u_x_tex, uv + vec2(texel_size.x, 0));
    vec4 x_t = texture(u_x_tex, uv + vec2(0, texel_size.y));
    vec4 x_b = texture(u_x_tex, uv - vec2(0, texel_size.y));
    vec4 b = texture(u_b_tex, uv);

    // Jacobi iteration
    vec4 new_x = (b + u_alpha * (x_l + x_r + x_t + x_b)) * u_beta_reciprocal;
    imageStore(u_write_tex, coord, new_x);
}
)";

const char* COMPUTE_DIVERGENCE_SHADER_SRC = R"(
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_vel_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(coord) + 0.5) / float(GRID_SIZE);
    vec2 texel_size = vec2(1.0 / float(GRID_SIZE));

    // Sample velocity components from neighbors
    float v_l = texture(u_vel_tex, uv - vec2(texel_size.x, 0)).g;
    float v_r = texture(u_vel_tex, uv + vec2(texel_size.x, 0)).g;
    float v_t = texture(u_vel_tex, uv + vec2(0, texel_size.y)).b;
    float v_b = texture(u_vel_tex, uv - vec2(0, texel_size.y)).b;

    // Compute divergence
    float divergence = 0.5 * (v_r - v_l + v_t - v_b);
    // Store divergence in .r, clear other channels
    imageStore(u_write_tex, coord, vec4(divergence, 0, 0, 0));
}
)";

const char* COMPUTE_SUBTRACT_GRADIENT_SHADER_SRC = R"(
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_vel_tex;
layout(binding = 1) uniform sampler2D u_pressure_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(coord) + 0.5) / float(GRID_SIZE);
    vec2 texel_size = vec2(1.0 / float(GRID_SIZE));

    // Sample pressure from neighbors
    float p_l = texture(u_pressure_tex, uv - vec2(texel_size.x, 0)).r;
    float p_r = texture(u_pressure_tex, uv + vec2(texel_size.x, 0)).r;
    float p_t = texture(u_pressure_tex, uv + vec2(0, texel_size.y)).r;
    float p_b = texture(u_pressure_tex, uv - vec2(0, texel_size.y)).r;

    // Subtract pressure gradient from velocity
    vec4 vel = texture(u_vel_tex, uv);
    vel.gb -= 0.5 * vec2(p_r - p_l, p_t - p_b);
    imageStore(u_write_tex, coord, vel);
}
)";

const char* COMPUTE_BOUNDARY_SHADER_SRC = R"(
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
// Use image for read-write to modify in place
layout(binding = 0, rgba32f) uniform image2D u_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(u_tex);

    // Only run on boundary pixels
    if (coord.x > 0 && coord.x < size.x - 1 && coord.y > 0 && coord.y < size.y - 1) return;

    ivec2 inner_coord = clamp(coord, ivec2(1), size - 2);
    vec4 inner_val = imageLoad(u_tex, inner_coord);
    vec4 boundary_val = inner_val; // Start with zero-gradient for density
    
    // Reflective (no-slip) boundary for velocity
    if (coord.x == 0 || coord.x == size.x - 1) {
        boundary_val.g = -inner_val.g; // Flip x-velocity
    }
    if (coord.y == 0 || coord.y == size.y - 1) {
        boundary_val.b = -inner_val.b; // Flip y-velocity
    }

    imageStore(u_tex, coord, boundary_val);
}
)";


class Fluid {
public:
    // Ping-pong textures for simulation and pressure
    GLuint sim_tex_a, sim_tex_b;
    GLuint pressure_tex_a, pressure_tex_b;
    // Shader programs
    GLuint advect_shader, jacobi_shader, divergence_shader, subtract_gradient_shader, boundary_shader, add_force_shader;
    // Fullscreen quad
    GLuint VAO, VBO;

    Fluid() {
        // Empty constructor
    }

    void init() {
        init_textures();
        init_shaders();
        init_quad();
    }

    void init_textures() {
        auto create_tex = []() {
            GLuint tex;
            glGenTextures(1, &tex);
            glBindTexture(GL_TEXTURE_2D, tex);
            // Use RGBA32F for high precision
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, GRID_SIZE, GRID_SIZE, 0, GL_RGBA, GL_FLOAT, nullptr);
            // Use linear filtering for smoother advection
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            
            // Clear texture using an FBO, as glClearTexImage may not be available
            GLuint fbo;
            glGenFramebuffers(1, &fbo);
            glBindFramebuffer(GL_FRAMEBUFFER, fbo);
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);
            if (glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) {
                glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
                glClear(GL_COLOR_BUFFER_BIT);
            }
            glBindFramebuffer(GL_FRAMEBUFFER, 0);
            glDeleteFramebuffers(1, &fbo);

            return tex;
        };
        sim_tex_a = create_tex();
        sim_tex_b = create_tex();
        pressure_tex_a = create_tex();
        pressure_tex_b = create_tex();
    }

    void init_shaders() {
        auto create_program = [](const char* src) {
            str full_src = build_shader_source(src, GRID_SIZE);
            const char* c_src = full_src.c_str();
            GLuint shader = glCreateShader(GL_COMPUTE_SHADER);
            glShaderSource(shader, 1, &c_src, nullptr);
            glCompileShader(shader);
            // Error checking...
            GLint success;
            glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
            if (!success) {
                char log[1024];
                glGetShaderInfoLog(shader, 1024, nullptr, log);
                io::println(io::err, "Compute shader compilation failed:\n", log);
            }
            GLuint program = glCreateProgram();
            glAttachShader(program, shader);
            glLinkProgram(program);
            glDeleteShader(shader);
            return program;
        };
        advect_shader = create_program(COMPUTE_ADVECT_SHADER_SRC);
        jacobi_shader = create_program(COMPUTE_JACOBI_SHADER_SRC);
        divergence_shader = create_program(COMPUTE_DIVERGENCE_SHADER_SRC);
        subtract_gradient_shader = create_program(COMPUTE_SUBTRACT_GRADIENT_SHADER_SRC);
        boundary_shader = create_program(COMPUTE_BOUNDARY_SHADER_SRC);
        add_force_shader = create_program(COMPUTE_ADD_FORCE_SHADER_SRC);
    }
    
    void init_quad() {
        float quad[] = {
            -1.0f,  1.0f,  0.0f, 1.0f,
            -1.0f, -1.0f,  0.0f, 0.0f,
             1.0f,  1.0f,  1.0f, 1.0f,
             1.0f, -1.0f,  1.0f, 0.0f,
        };
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(quad), quad, GL_STATIC_DRAW);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
        glEnableVertexAttribArray(1);
    }

    void swap_sim_textures() { std::swap(sim_tex_a, sim_tex_b); }
    void swap_pressure_textures() { std::swap(pressure_tex_a, pressure_tex_b); }

    void dispatch(GLuint shader) {
        glUseProgram(shader);
        glDispatchCompute(GRID_SIZE / 8, GRID_SIZE / 8, 1);
        // Ensure writes are visible to subsequent reads
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_TEXTURE_FETCH_BARRIER_BIT);
    }

    void add_force(float x, float y, float dx, float dy, float density) {
        glUseProgram(add_force_shader);
        // Bind the current simulation texture for read-write
        glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        glUniform2f(glGetUniformLocation(add_force_shader, "u_point"), x, y);
        glUniform1f(glGetUniformLocation(add_force_shader, "u_radius"), 5.0f);
        
        // Add density and velocity in separate passes
        if (density > 0.0f) {
            glUniform4f(glGetUniformLocation(add_force_shader, "u_value"), density, 0.0f, 0.0f, 0.0f);
            dispatch(add_force_shader);
        }
        if (dx != 0.0f || dy != 0.0f) {
            glUniform4f(glGetUniformLocation(add_force_shader, "u_value"), 0.0f, dx, dy, 0.0f);
            dispatch(add_force_shader);
        }
    }

    void advect() {
        glUseProgram(advect_shader);
        // Write to B, read from A
        glBindImageTexture(0, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(advect_shader, "u_read_tex"), 0);
        glUniform1f(glGetUniformLocation(advect_shader, "u_dt"), DT);
        dispatch(advect_shader);
        swap_sim_textures();
    }

    void diffuse(float rate) {
        if (rate <= 0.0) return;
        float alpha = (GRID_SIZE * GRID_SIZE) / (rate * DT);
        glUseProgram(jacobi_shader);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_alpha"), alpha);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_beta_reciprocal"), 1.0f / (4.0f + alpha));
        
        // B is the constant term (initial state)
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_b_tex"), 1);

        glActiveTexture(GL_TEXTURE0);
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_x_tex"), 0);

        for (int i = 0; i < 20; ++i) {
            // Write to B, read from A
            glBindImageTexture(0, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
            glBindTexture(GL_TEXTURE_2D, sim_tex_a);
            dispatch(jacobi_shader);
            swap_sim_textures();
        }
    }

    void project() {
        // Calculate divergence of velocity field (read from sim_a, write to pressure_a)
        glUseProgram(divergence_shader);
        glBindImageTexture(0, pressure_tex_a, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(divergence_shader, "u_vel_tex"), 0);
        dispatch(divergence_shader);

        // Solve for pressure (Jacobi)
        glUseProgram(jacobi_shader);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_alpha"), -GRID_SIZE * GRID_SIZE);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_beta_reciprocal"), 1.0f / 4.0f);
        
        // Divergence is the constant term 'b'
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, pressure_tex_a);
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_b_tex"), 1);
        
        glActiveTexture(GL_TEXTURE0);
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_x_tex"), 0);

        for (int i = 0; i < 20; ++i) {
            // Write to pressure_b, read from pressure_a
            glBindImageTexture(0, pressure_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
            glBindTexture(GL_TEXTURE_2D, pressure_tex_a);
            dispatch(jacobi_shader);
            swap_pressure_textures();
        }

        // Subtract pressure gradient from velocity field
        glUseProgram(subtract_gradient_shader);
        // Write to sim_b, read from sim_a (velocity) and pressure_a (pressure)
        glBindImageTexture(0, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(subtract_gradient_shader, "u_vel_tex"), 0);
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, pressure_tex_a);
        glUniform1i(glGetUniformLocation(subtract_gradient_shader, "u_pressure_tex"), 1);
        dispatch(subtract_gradient_shader);
        swap_sim_textures();
    }
    
    void set_boundary() {
        glUseProgram(boundary_shader);
        glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        dispatch(boundary_shader);
    }

    void step() {
        // Advect velocity and density
        advect();
        set_boundary();
        
        // Diffuse velocity (viscosity)
        diffuse(VISCOSITY);
        set_boundary();

        // Make velocity field mass-conserving
        project();
        set_boundary();
        
        // Diffuse density
        diffuse(DIFFUSION);
        set_boundary();
    }

    void render(GLuint display_shader) {
        glUseProgram(display_shader);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(display_shader, "uSimData"), 0);
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    }
};

int main(vec<str> args) {
    if (!glfwInit()) {
        return -1;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
    glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4x MSAA

    GLFWwindow* window = glfwCreateWindow(WINDOW_SIZE, WINDOW_SIZE, "Fluid Sim", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
    glViewport(0, 0, WINDOW_SIZE, WINDOW_SIZE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    // set up anti-aliasing
    glEnable(GL_MULTISAMPLE);


    Fluid fluid;
    fluid.init();

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    GLuint shaderProgram = createShaderProgram(VERTEX_SHADER, FRAGMENT_SHADER);
    
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();

        static double prevMouseX = 0.0, prevMouseY = 0.0;

        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) {
            double mouseX, mouseY;
            glfwGetCursorPos(window, &mouseX, &mouseY);
            mouseY = WINDOW_SIZE - mouseY; // Invert Y coordinate

            float x = mouseX / SCALE;
            float y = mouseY / SCALE;

            if (x >= 1 && x < GRID_SIZE - 1 && y >= 1 && y < GRID_SIZE - 1) {
                float dx = static_cast<float>(mouseX - prevMouseX);
                float dy = static_cast<float>(mouseY - prevMouseY);

                const float maxSpeed = 10.0f;
                float len = math::sqrt(dx * dx + dy * dy);
                if (len > maxSpeed) {
                    dx = dx / len * maxSpeed;
                    dy = dy / len * maxSpeed;
                }

                const float densityStrength = 300.0f;
                const float velocityStrength = 15.0f;
                
                fluid.add_force(x, y, dx * velocityStrength, dy * velocityStrength, densityStrength);
            }

            prevMouseX = mouseX;
            prevMouseY = mouseY;
        } else {
            glfwGetCursorPos(window, &prevMouseX, &prevMouseY);
        }

        fluid.step();
        
        glClear(GL_COLOR_BUFFER_BIT);
        fluid.render(shaderProgram);

        glfwSwapBuffers(window);

        // sleep
        std::this_thread::sleep_for(std::chrono::milliseconds(16)); // ~60 FPS
    }

    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
}