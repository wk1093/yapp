#import std.math
#import std.io

#import <glad/glad.h>
#import <GLFW/glfw3.h>
#import <SFML/Graphics.hpp>


const int GRID_SIZE = 64*2; // Grid resolution (64x64)
const float DT = 0.1f; // Time step
const float DIFFUSION = 0.00001f; // Diffusion rate
const float VISCOSITY = 0.0001f; // Viscosity
const int WINDOW_SIZE = 64*4; // Window size in pixels
const float SCALE = (float)(WINDOW_SIZE) / GRID_SIZE; // Scale factor for rendering

const char* VERTEX_SHADER = R"(#version 330 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTex;

out vec2 TexCoord;

void main() {
    TexCoord = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
)";

const char* FRAGMENT_SHADER =R"(#version 330 core
out vec4 FragColor;

in vec2 TexCoord;
uniform sampler2D uTexture;

void main() {
    FragColor = texture(uTexture, TexCoord);
}
)";

// Helper function to convert 2D grid indices to 1D array index
int IX(int x, int y) {
    x = math::max(0, math::min(x, GRID_SIZE - 1));
    y = math::max(0, math::min(y, GRID_SIZE - 1));
    return x + y * GRID_SIZE;
}

GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    int length = strlen(source);
    glShaderSource(shader, 1, &source, &length);
    glCompileShader(shader);

    // Check for errors
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        io::println(io::err, "Shader compilation failed: ", log);
    }

    return shader;
}

GLuint createShaderProgram(const char* vertexSrc, const char* fragmentSrc) {
    GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexSrc);
    GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentSrc);

    GLuint program = glCreateProgram();
    glAttachShader(program, vertShader);
    glAttachShader(program, fragShader);
    glLinkProgram(program);

    // Check for linking errors
    GLint success;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        char log[512];
        glGetProgramInfoLog(program, 512, nullptr, log);
        io::println(io::err, "Program linking failed: ", log);
    }

    glDeleteShader(vertShader);
    glDeleteShader(fragShader);

    return program;
}

sf::Color HSVtoRGB(float h, float s, float v) {
    float c = v * s;
    float x = c * (1 - fabs(fmod(h / 60.0f, 2) - 1));
    float m = v - c;
    float r, g, b;

    if (h < 60)      { r = c; g = x; b = 0; }
    else if (h < 120){ r = x; g = c; b = 0; }
    else if (h < 180){ r = 0; g = c; b = x; }
    else if (h < 240){ r = 0; g = x; b = c; }
    else if (h < 300){ r = x; g = 0; b = c; }
    else             { r = c; g = 0; b = x; }

    return sf::Color(
        (sf::Uint8)((r + m) * 255),
        (sf::Uint8)((g + m) * 255),
        (sf::Uint8)((b + m) * 255)
    );
}


class Fluid {
public:
    Fluid() : u(GRID_SIZE * GRID_SIZE), v(GRID_SIZE * GRID_SIZE),
          u_prev(GRID_SIZE * GRID_SIZE), v_prev(GRID_SIZE * GRID_SIZE),
          density(GRID_SIZE * GRID_SIZE), density_prev(GRID_SIZE * GRID_SIZE) {
    initGLTexture();
}


    void addDensity(int x, int y, float amount) {
        density[IX(x, y)] += amount;
    }

    void addVelocity(int x, int y, float amountX, float amountY) {
        u[IX(x, y)] += amountX;
        v[IX(x, y)] += amountY;
    }

    void step() {
        diffuse(1, u_prev, u, VISCOSITY);
        diffuse(2, v_prev, v, VISCOSITY);
        project(u_prev, v_prev, u, v);
        advect(1, u, u_prev, u_prev, v_prev);
        advect(2, v, v_prev, u_prev, v_prev);
        project(u, v, u_prev, v_prev);
        diffuse(0, density_prev, density, DIFFUSION);
        advect(0, density, density_prev, u, v);
    }

    void render() {
        for (int j = 0; j < GRID_SIZE; ++j) {
            for (int i = 0; i < GRID_SIZE; ++i) {
                int idx = IX(i, j);
                float d = density[idx];
                float speed = math::sqrt(u[idx] * u[idx] + v[idx] * v[idx]);

                d = math::min(d, 255.0f);
                speed = math::min(speed, 10.0f);

                float curvedSpeed = math::sqrt(speed);
                float hue = math::fmod(360.0f * 2.0f * (curvedSpeed / math::sqrt(10.0f)), 360.0f);
                float brightness = d / 255.0f;
                float saturation = 1.0f;

                sf::Color c = HSVtoRGB(hue, saturation, brightness);
                int base = 3 * (j * GRID_SIZE + i);
                pixelBuffer[base + 0] = c.r;
                pixelBuffer[base + 1] = c.g;
                pixelBuffer[base + 2] = c.b;
            }
        }

        glBindTexture(GL_TEXTURE_2D, textureID);
        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, GRID_SIZE, GRID_SIZE, GL_RGB, GL_UNSIGNED_BYTE, pixelBuffer.data());

        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    }


private:
    vec<float> u, v; // Velocity field (x, y components)
    vec<float> u_prev, v_prev; // Previous velocity field
    vec<float> density, density_prev; // Density field
    GLuint textureID;
    vec<uint8_t> pixelBuffer;

    void initGLTexture() {
        glGenTextures(1, &textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); 

        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, GRID_SIZE, GRID_SIZE, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
        pixelBuffer.resize(GRID_SIZE * GRID_SIZE * 3);
    }

    void diffuse(int b, vec<float>& x, vec<float>& x0, float diff) {
        float a = DT * diff * (GRID_SIZE - 2) * (GRID_SIZE - 2);
        linearSolve(b, x, x0, a, 1 + 4 * a);
    }

    void advect(int b, vec<float>& d, vec<float>& d0,
                vec<float>& u, vec<float>& v) {
        float dt0 = DT * (GRID_SIZE - 2);
        #pragma omp parallel for collapse(2)
        for (int i = 1; i < GRID_SIZE - 1; ++i) {
            for (int j = 1; j < GRID_SIZE - 1; ++j) {
                float x = i - dt0 * u[IX(i, j)];
                float y = j - dt0 * v[IX(i, j)];
                x = math::max(0.5f, math::min((float)(GRID_SIZE) - 1.5f, x));
                y = math::max(0.5f, math::min((float)(GRID_SIZE) - 1.5f, y));
                int i0 = (int)(x), i1 = i0 + 1;
                int j0 = (int)(y), j1 = j0 + 1;
                float s1 = x - i0, s0 = 1 - s1;
                float t1 = y - j0, t0 = 1 - t1;
                d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                              s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
            }
        }
        setBoundary(b, d);
    }

    void project(vec<float>& u, vec<float>& v,
                 vec<float>& p, vec<float>& div) {
        #pragma omp parallel for collapse(2)
        for (int i = 1; i < GRID_SIZE - 1; ++i) {
            for (int j = 1; j < GRID_SIZE - 1; ++j) {
                div[IX(i, j)] = -0.5f * (
                    u[IX(i + 1, j)] - u[IX(i - 1, j)] +
                    v[IX(i, j + 1)] - v[IX(i, j - 1)]
                ) / GRID_SIZE;
                p[IX(i, j)] = 0;
            }
        }
        setBoundary(0, div);
        setBoundary(0, p);
        linearSolve(0, p, div, 1, 4);
        for (int i = 1; i < GRID_SIZE - 1; ++i) {
            for (int j = 1; j < GRID_SIZE - 1; ++j) {
                u[IX(i, j)] -= 0.5f * GRID_SIZE * (p[IX(i + 1, j)] - p[IX(i - 1, j)]);
                v[IX(i, j)] -= 0.5f * GRID_SIZE * (p[IX(i, j + 1)] - p[IX(i, j - 1)]);
            }
        }
        setBoundary(1, u);
        setBoundary(2, v);
    }

    void linearSolve(int b, vec<float>& x, vec<float>& x0, float a, float c) {

        for (int k = 0; k < 20; ++k) { // Iterative solver (Gauss-Seidel)
            #pragma omp parallel for collapse(2)
            for (int i = 1; i < GRID_SIZE - 1; ++i) {
                for (int j = 1; j < GRID_SIZE - 1; ++j) {
                    x[IX(i, j)] = (x0[IX(i, j)] +
                                   a * (x[IX(i + 1, j)] + x[IX(i - 1, j)] +
                                        x[IX(i, j + 1)] + x[IX(i, j - 1)])) / c;
                }
            }
            setBoundary(b, x);
        }
    }

    void setBoundary(int b, vec<float>& x) {
        for (int i = 1; i < GRID_SIZE - 1; ++i) {
            x[IX(i, 0)] = b == 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
            x[IX(i, GRID_SIZE - 1)] = b == 2 ? -x[IX(i, GRID_SIZE - 2)] : x[IX(i, GRID_SIZE - 2)];
            x[IX(0, i)] = b == 1 ? -x[IX(1, i)] : x[IX(1, i)];
            x[IX(GRID_SIZE - 1, i)] = b == 1 ? -x[IX(GRID_SIZE - 2, i)] : x[IX(GRID_SIZE - 2, i)];
        }
        x[IX(0, 0)] = 0.5f * (x[IX(1, 0)] + x[IX(0, 1)]);
        x[IX(0, GRID_SIZE - 1)] = 0.5f * (x[IX(1, GRID_SIZE - 1)] + x[IX(0, GRID_SIZE - 2)]);
        x[IX(GRID_SIZE - 1, 0)] = 0.5f * (x[IX(GRID_SIZE - 2, 0)] + x[IX(GRID_SIZE - 1, 1)]);
        x[IX(GRID_SIZE - 1, GRID_SIZE - 1)] = 0.5f * (x[IX(GRID_SIZE - 2, GRID_SIZE - 1)] + x[IX(GRID_SIZE - 1, GRID_SIZE - 2)]);
    }
};

int main(vec<str> args) {
    if (!glfwInit()) {
        return -1;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
    glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4x MSAA

    GLFWwindow* window = glfwCreateWindow(WINDOW_SIZE, WINDOW_SIZE, "Fluid Sim", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
    glViewport(0, 0, WINDOW_SIZE, WINDOW_SIZE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    // set up anti-aliasing
    glEnable(GL_MULTISAMPLE);


    float quad[] = {
    -1.0f,  1.0f,  0.0f, 1.0f,
    -1.0f, -1.0f,  0.0f, 0.0f,
     1.0f,  1.0f,  1.0f, 1.0f,
     1.0f, -1.0f,  1.0f, 0.0f,
};

GLuint VAO, VBO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);

glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(quad), quad, GL_STATIC_DRAW);

glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
glEnableVertexAttribArray(1);

    Fluid fluid;

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    GLuint shaderProgram = createShaderProgram(VERTEX_SHADER, FRAGMENT_SHADER);
    glUseProgram(shaderProgram);

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();

static double prevMouseX = 0.0, prevMouseY = 0.0;

if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) {
    double mouseX, mouseY;
    glfwGetCursorPos(window, &mouseX, &mouseY);
    mouseY = WINDOW_SIZE - mouseY; // Invert Y coordinate

    int x = static_cast<int>(mouseX / SCALE);
    int y = static_cast<int>(mouseY / SCALE);

    if (x >= 1 && x < GRID_SIZE - 1 && y >= 1 && y < GRID_SIZE - 1) {
        float dx = static_cast<float>(mouseX - prevMouseX) / SCALE;
        float dy = static_cast<float>(mouseY - prevMouseY) / SCALE;

        const float maxSpeed = 10.0f;
        float len = math::sqrt(dx * dx + dy * dy);
        if (len > maxSpeed) {
            dx = dx / len * maxSpeed;
            dy = dy / len * maxSpeed;
        }

        const int radius = 2;
        const float densityStrength = 300.0f;
        const float velocityStrength = 15.0f;

        for (int j = -radius; j <= radius; ++j) {
            for (int i = -radius; i <= radius; ++i) {
                int xi = x + i;
                int yj = y + j;
                if (xi >= 1 && xi < GRID_SIZE - 1 && yj >= 1 && yj < GRID_SIZE - 1) {
                    float dist2 = i * i + j * j;
                    if (dist2 <= radius * radius) {
                        float falloff = 1.0f - dist2 / (radius * radius);
                        fluid.addDensity(xi, yj, densityStrength * falloff);
                        // fluid.addVelocity(xi, yj, dx * velocityStrength * falloff, dy * velocityStrength * falloff);
                    }
                }
            }
        }

        fluid.addVelocity(x, y, dx * velocityStrength, dy * velocityStrength);
    }

    prevMouseX = mouseX;
    prevMouseY = mouseY;
} else {
    glfwGetCursorPos(window, &prevMouseX, &prevMouseY);
}

        fluid.step();

        glClear(GL_COLOR_BUFFER_BIT);
        glBindVertexArray(VAO);
        fluid.render();
        glfwSwapBuffers(window);
    }

    glfwDestroyWindow(window);
glfwTerminate();

    return 0;
}