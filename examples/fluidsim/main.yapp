#import std.math
#import std.io
#import <thread>

#import <glad/glad.h>
#import <GLFW/glfw3.h>


const int GRID_SIZE = 64*4; // Grid resolution (64x64)
const float DT = 0.1f; // Time step
const float DIFFUSION = 0.00001f; // Diffusion rate
const float VISCOSITY = 0.0001f; // Viscosity
const int WINDOW_SIZE = 64*8; // Window size in pixels
const float SCALE = (float)(WINDOW_SIZE) / GRID_SIZE; // Scale factor for rendering

const char* VERTEX_SHADER = R"(#version 430 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTex;

out vec2 TexCoord;

void main() {
    TexCoord = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
)";

const char* FRAGMENT_SHADER =R"(#version 430 core
out vec4 FragColor;

in vec2 TexCoord;
uniform sampler2D uSimData; // RGBA32F: r=density, g=u, b=v, a=unused

void main() {
    // Fetch the simulation data (density in the .r component)
    float density = texture(uSimData, TexCoord).r;

    // Normalize and clamp the density for visualization
    // The value 255.0 is arbitrary; it can be tuned to make the fluid more/less visible.
    float color = clamp(density / 100.0, 0.0, 1.0);

    // Output a grayscale color. This is stable and won't flash.
    FragColor = vec4(color, color, color, 1.0);
}
)";

// Helper function to convert 2D grid indices to 1D array index
int idx(int x, int y, int width) {
    return x + y * width;
}

const char* COMPUTE_ADVECT_SHADER_SRC = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D u_read_tex;
layout(binding = 1, rgba32f) uniform writeonly image2D u_write_tex;

uniform float u_dt;
uniform vec2 u_grid_size;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 pos = vec2(coord) / u_grid_size;

    // Read velocity at the current position
    vec2 vel = texelFetch(u_read_tex, coord, 0).gb;

    // Trace back in time
    vec2 prev_pos = pos - (vel * u_dt);

    // Bilinear interpolation
    vec4 data = texture(u_read_tex, prev_pos);

    imageStore(u_write_tex, coord, data);
}
)";

const char* COMPUTE_JACOBI_DIFFUSE_SHADER_SRC = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D u_x_read_tex;  // x_k (current iteration value)
layout(binding = 1) uniform sampler2D u_x0_read_tex; // x0 (initial value)
layout(binding = 2, rgba32f) uniform writeonly image2D u_x_write_tex; // x_k+1

uniform float u_a;
uniform float u_c_inv; // 1.0 / c = 1.0 / (1 + 4*a)

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Sample neighbors from the read texture (x_k)
    vec4 x_l = texelFetch(u_x_read_tex, coord + ivec2(-1, 0), 0);
    vec4 x_r = texelFetch(u_x_read_tex, coord + ivec2(1, 0), 0);
    vec4 x_t = texelFetch(u_x_read_tex, coord + ivec2(0, 1), 0);
    vec4 x_b = texelFetch(u_x_read_tex, coord + ivec2(0, -1), 0);
    vec4 neighbors_sum = x_l + x_r + x_t + x_b;

    // Sample from the x0 texture
    vec4 x0 = texelFetch(u_x0_read_tex, coord, 0);

    // Jacobi iteration for diffusion: x_k+1 = (x0 + a * sum(neighbors_k)) / (1 + 4*a)
    vec4 x_new = (x0 + u_a * neighbors_sum) * u_c_inv;

    imageStore(u_x_write_tex, coord, x_new);
}
)";

const char* COMPUTE_JACOBI_FOR_PRESSURE_SHADER_SRC = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D u_pressure_read_tex; // p_k
layout(binding = 1) uniform sampler2D u_divergence_tex;    // b
layout(binding = 2, rgba32f) uniform writeonly image2D u_pressure_write_tex; // p_k+1

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Sample neighbors from the read texture (p_k)
    float p_l = texelFetch(u_pressure_read_tex, coord + ivec2(-1, 0), 0).r;
    float p_r = texelFetch(u_pressure_read_tex, coord + ivec2(1, 0), 0).r;
    float p_t = texelFetch(u_pressure_read_tex, coord + ivec2(0, 1), 0).r;
    float p_b = texelFetch(u_pressure_read_tex, coord + ivec2(0, -1), 0).r;

    // Sample from the b texture (divergence)
    float divergence = texelFetch(u_divergence_tex, coord, 0).r;

    // Jacobi iteration for Poisson equation: laplacian(p) = divergence
    // p_k+1 = (p_l + p_r + p_t + p_b - divergence) / 4.0
    float p_new = (p_l + p_r + p_t + p_b - divergence) / 4.0;

    // Store new pressure value. Other components are not used.
    imageStore(u_pressure_write_tex, coord, vec4(p_new, 0, 0, 0));
}
)";


const char* COMPUTE_DIVERGENCE_SHADER_SRC = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_vel_tex; // Vel texture has u in .g, v in .b
layout(binding = 1, rgba32f) uniform writeonly image2D u_write_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Sample velocity components from neighbors
    float u_l = texelFetch(u_vel_tex, coord + ivec2(-1, 0), 0).g; // u at left
    float u_r = texelFetch(u_vel_tex, coord + ivec2(1, 0), 0).g;  // u at right
    float v_b = texelFetch(u_vel_tex, coord + ivec2(0, -1), 0).b; // v at bottom
    float v_t = texelFetch(u_vel_tex, coord + ivec2(0, 1), 0).b;  // v at top

    // Compute divergence using central differences.
    // div = 0.5 * ( (u_r - u_l)/dx + (v_t - v_b)/dy ).
    // Since dx=dy=1 in grid space, we get:
    float divergence = 0.5 * (u_r - u_l + v_t - v_b);
    
    // Store divergence in .r, clear other channels
    imageStore(u_write_tex, coord, vec4(divergence, 0, 0, 0));
}
)";

const char* COMPUTE_SUBTRACT_GRADIENT_SHADER_SRC = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_vel_tex;
layout(binding = 1) uniform sampler2D u_pressure_tex;
layout(binding = 2, rgba32f) uniform writeonly image2D u_write_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Sample pressure from neighbors
    float p_l = texelFetch(u_pressure_tex, coord + ivec2(-1, 0), 0).r;
    float p_r = texelFetch(u_pressure_tex, coord + ivec2(1, 0), 0).r;
    float p_t = texelFetch(u_pressure_tex, coord + ivec2(0, 1), 0).r;
    float p_b = texelFetch(u_pressure_tex, coord + ivec2(0, -1), 0).r;

    // Subtract pressure gradient from velocity.
    // vel -= grad(p) = 0.5 * (p_r - p_l, p_t - p_b)
    vec4 vel = texelFetch(u_vel_tex, coord, 0);
    vel.gb -= 0.5 * vec2(p_r - p_l, p_t - p_b);
    imageStore(u_write_tex, coord, vel);
}
)";

const char* COMPUTE_BOUNDARY_SHADER_SRC = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba32f) uniform image2D u_texture;

uniform int u_mode; // 0 for scalar (density/pressure), 1 for u, 2 for v
uniform ivec2 u_grid_size;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Only operate on boundary pixels
    if (coord.x == 0 || coord.x == u_grid_size.x - 1 || coord.y == 0 || coord.y == u_grid_size.y - 1) {
        vec4 val = imageLoad(u_texture, coord);
        
        if (u_mode == 0) { // Scalar field (density, pressure)
            // Neumann boundary (zero gradient)
            if (coord.x == 0) val = imageLoad(u_texture, ivec2(1, coord.y));
            if (coord.x == u_grid_size.x - 1) val = imageLoad(u_texture, ivec2(u_grid_size.x - 2, coord.y));
            if (coord.y == 0) val = imageLoad(u_texture, ivec2(coord.x, 1));
            if (coord.y == u_grid_size.y - 1) val = imageLoad(u_texture, ivec2(coord.x, u_grid_size.y - 2));
        } else if (u_mode == 1) { // u-velocity
            // Reflective boundary for u
            if (coord.x == 0 || coord.x == u_grid_size.x - 1) val.g = -val.g;
        } else if (u_mode == 2) { // v-velocity
            // Reflective boundary for v
            if (coord.y == 0 || coord.y == u_grid_size.y - 1) val.b = -val.b;
        }
        
        imageStore(u_texture, coord, val);

        // Handle corners
        if (coord.x == 0 && coord.y == 0) {
            vec4 val1 = imageLoad(u_texture, ivec2(1, 0));
            vec4 val2 = imageLoad(u_texture, ivec2(0, 1));
            imageStore(u_texture, coord, (val1 + val2) * 0.5f);
        }
        if (coord.x == u_grid_size.x - 1 && coord.y == 0) {
            vec4 val1 = imageLoad(u_texture, ivec2(u_grid_size.x - 2, 0));
            vec4 val2 = imageLoad(u_texture, ivec2(u_grid_size.x - 1, 1));
            imageStore(u_texture, coord, (val1 + val2) * 0.5f);
        }
        if (coord.x == 0 && coord.y == u_grid_size.y - 1) {
            vec4 val1 = imageLoad(u_texture, ivec2(1, u_grid_size.y - 1));
            vec4 val2 = imageLoad(u_texture, ivec2(0, u_grid_size.y - 2));
            imageStore(u_texture, coord, (val1 + val2) * 0.5f);
        }
        if (coord.x == u_grid_size.x - 1 && coord.y == u_grid_size.y - 1) {
            vec4 val1 = imageLoad(u_texture, ivec2(u_grid_size.x - 2, u_grid_size.y - 1));
            vec4 val2 = imageLoad(u_texture, ivec2(u_grid_size.x - 1, u_grid_size.y - 2));
            imageStore(u_texture, coord, (val1 + val2) * 0.5f);
        }
    }
}
)";

GLuint create_texture(int width, int height, GLenum format) {
    GLuint tex;
    glGenTextures(1, &tex);
    glBindTexture(GL_TEXTURE_2D, tex);
    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, GL_RGBA, GL_FLOAT, nullptr);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    return tex;
}

GLuint create_compute_shader(const char* source) {
    GLuint shader = glCreateShader(GL_COMPUTE_SHADER);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);

    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char infoLog[512];
        glGetShaderInfoLog(shader, 512, nullptr, infoLog);
        printf("ERROR::SHADER::COMPUTE::COMPILATION_FAILED\n%s\n", infoLog);
        return 0;
    }
    return shader;
}


class Fluid {
public:
    // Simulation parameters
    int grid_width, grid_height;
    float dt;
    float viscosity;
    float diffusion;

    // OpenGL resources
    GLuint sim_tex_a, sim_tex_b; // Ping-pong textures for simulation data (density, u, v)
    GLuint pressure_tex_a, pressure_tex_b; // Ping-pong textures for pressure solve
    GLuint divergence_tex; // Texture to store divergence field
    GLuint VAO, VBO;

    GLuint advect_shader;
    GLuint jacobi_diffuse_shader;
    GLuint jacobi_pressure_shader;
    GLuint divergence_shader;
    GLuint subtract_gradient_shader;
    GLuint boundary_shader;

    Fluid(int width, int height, float dt, float viscosity, float diffusion)
        : grid_width(width), grid_height(height), dt(dt), viscosity(viscosity), diffusion(diffusion) {}

    void init() {
        // Create textures
        sim_tex_a = create_texture(grid_width, grid_height, GL_RGBA32F);
        sim_tex_b = create_texture(grid_width, grid_height, GL_RGBA32F);
        pressure_tex_a = create_texture(grid_width, grid_height, GL_R32F);
        pressure_tex_b = create_texture(grid_width, grid_height, GL_R32F);
        divergence_tex = create_texture(grid_width, grid_height, GL_R32F);

        // Create compute shaders
        advect_shader = create_compute_shader(COMPUTE_ADVECT_SHADER_SRC);
        jacobi_diffuse_shader = create_compute_shader(COMPUTE_JACOBI_DIFFUSE_SHADER_SRC);
        jacobi_pressure_shader = create_compute_shader(COMPUTE_JACOBI_FOR_PRESSURE_SHADER_SRC);
        divergence_shader = create_compute_shader(COMPUTE_DIVERGENCE_SHADER_SRC);
        subtract_gradient_shader = create_compute_shader(COMPUTE_SUBTRACT_GRADIENT_SHADER_SRC);
        boundary_shader = create_compute_shader(COMPUTE_BOUNDARY_SHADER_SRC);

        init_quad();
    }

    void clear_texture(GLuint tex, GLenum format) {
        GLuint fbo;
        glGenFramebuffers(1, &fbo);
        glBindFramebuffer(GL_FRAMEBUFFER, fbo);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);
        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) {
            const GLfloat color[] = { 0.0f, 0.0f, 0.0f, 0.0f };
            glClearBufferfv(GL_COLOR, 0, color);
        }
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glDeleteFramebuffers(1, &fbo);
    }

    void init_quad() {
        float quad[] = {
            // positions   // texCoords
            -1.0f,  1.0f,  0.0f, 1.0f,
            -1.0f, -1.0f,  0.0f, 0.0f,
             1.0f,  1.0f,  1.0f, 1.0f,
             1.0f, -1.0f,  1.0f, 0.0f,
        };
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(quad), &quad, GL_STATIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
    }

    void add_force(int x, int y, float amount_density, float force_x, float force_y) {
        // This function is slow, meant for user interaction, not per-frame simulation logic
        std::vector<float> data(grid_width * grid_height * 4);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_FLOAT, data.data());

        int center_idx = idx(x, y, grid_width) * 4;
        data[center_idx + 0] += amount_density; // Add density
        data[center_idx + 1] += force_x;        // Add u velocity
        data[center_idx + 2] += force_y;        // Add v velocity

        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, grid_width, grid_height, GL_RGBA, GL_FLOAT, data.data());
    }

    void set_boundary(int mode, GLuint tex) {
        glUseProgram(boundary_shader);
        glUniform1i(glGetUniformLocation(boundary_shader, "u_mode"), mode);
        glUniform2i(glGetUniformLocation(boundary_shader, "u_grid_size"), grid_width, grid_height);
        glBindImageTexture(0, tex, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        glDispatchCompute(grid_width / 8, grid_height / 8, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
    }

    void advect() {
        glUseProgram(advect_shader);
        glUniform1f(glGetUniformLocation(advect_shader, "u_dt"), dt);
        glUniform2f(glGetUniformLocation(advect_shader, "u_grid_size"), (float)grid_width, (float)grid_height);
        
        glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
        glBindImageTexture(1, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        
        glDispatchCompute(grid_width / 8, grid_height / 8, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

        std::swap(sim_tex_a, sim_tex_b);
    }

    void diffuse(float rate) {
        if (rate == 0) return;

        float a = dt * rate;
        float c_inv = 1.0f / (1.0f + 4.0f * a);

        glUseProgram(jacobi_diffuse_shader);
        glUniform1f(glGetUniformLocation(jacobi_diffuse_shader, "u_a"), a);
        glUniform1f(glGetUniformLocation(jacobi_diffuse_shader, "u_c_inv"), c_inv);
        glUniform1i(glGetUniformLocation(jacobi_diffuse_shader, "u_x_read_tex"), 0);
        glUniform1i(glGetUniformLocation(jacobi_diffuse_shader, "u_x0_read_tex"), 1);

        // Use divergence_tex as temporary storage for x0, since it's RGBA32F and not used here.
        glCopyImageSubData(sim_tex_a, GL_TEXTURE_2D, 0, 0, 0, 0,
                           divergence_tex, GL_TEXTURE_2D, 0, 0, 0, 0,
                           grid_width, grid_height, 1);

        for (int i = 0; i < 20; ++i) {
            glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F); // x_k
            glBindImageTexture(1, divergence_tex, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F); // x0
            glBindImageTexture(2, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F); // x_k+1
            
            glDispatchCompute(grid_width / 8, grid_height / 8, 1);
            glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

            std::swap(sim_tex_a, sim_tex_b);
            
            set_boundary(1, sim_tex_a);
            set_boundary(2, sim_tex_a);
        }
    }

    void project() {
        // Calculate divergence of velocity field (sim_tex_a) and store in divergence_tex
        glUseProgram(divergence_shader);
        glUniform1i(glGetUniformLocation(divergence_shader, "u_vel_tex"), 0);
        glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
        glBindImageTexture(1, divergence_tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_R32F);
        glDispatchCompute(grid_width / 8, grid_height / 8, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
        set_boundary(0, divergence_tex);

        // Zero out the initial pressure fields
        clear_texture(pressure_tex_a, GL_R32F);
        clear_texture(pressure_tex_b, GL_R32F);

        // Iteratively solve for pressure field using Jacobi method
        glUseProgram(jacobi_pressure_shader);
        glUniform1i(glGetUniformLocation(jacobi_pressure_shader, "u_pressure_read_tex"), 0);
        glUniform1i(glGetUniformLocation(jacobi_pressure_shader, "u_divergence_tex"), 1);

        for (int i = 0; i < 20; ++i) {
            glBindImageTexture(0, pressure_tex_a, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R32F);
            glBindImageTexture(1, divergence_tex, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R32F);
            glBindImageTexture(2, pressure_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_R32F);
            glDispatchCompute(grid_width / 8, grid_height / 8, 1);
            glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
            
            set_boundary(0, pressure_tex_b);
            std::swap(pressure_tex_a, pressure_tex_b);
        }

        // Subtract pressure gradient from velocity field
        glUseProgram(subtract_gradient_shader);
        glUniform1i(glGetUniformLocation(subtract_gradient_shader, "u_vel_tex"), 0);
        glUniform1i(glGetUniformLocation(subtract_gradient_shader, "u_pressure_tex"), 1);
        glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
        glBindImageTexture(1, pressure_tex_a, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R32F);
        glBindImageTexture(2, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glDispatchCompute(grid_width / 8, grid_height / 8, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

        std::swap(sim_tex_a, sim_tex_b);
        set_boundary(1, sim_tex_a);
        set_boundary(2, sim_tex_a);
    }

    void step() {
        // 1. Diffuse Velocity
        diffuse(viscosity);
        
        // 2. Project to make the flow incompressible
        project();
        
        // 3. Advect density and velocity fields
        advect();
    }

    void render(GLuint display_shader) {
        glUseProgram(display_shader);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(display_shader, "uSimData"), 0);
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    }
};

GLuint createShaderProgram(const char* vertexShaderSrc, const char* fragmentShaderSrc) {
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSrc, nullptr);
    glCompileShader(vertexShader);

    GLint success;
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char infoLog[512];
        glGetShaderInfoLog(vertexShader, 512, nullptr, infoLog);
        printf("ERROR::SHADER::VERTEX::COMPILATION_FAILED\n%s\n", infoLog);
        return 0;
    }

    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSrc, nullptr);
    glCompileShader(fragmentShader);

    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char infoLog[512];
        glGetShaderInfoLog(fragmentShader, 512, nullptr, infoLog);
        printf("ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n%s\n", infoLog);
        return 0;
    }

    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    return shaderProgram;
}

int main(vec<str> args) {
    if (!glfwInit()) {
        return -1;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
    glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4x MSAA

    GLFWwindow* window = glfwCreateWindow(WINDOW_SIZE, WINDOW_SIZE, "Fluid Sim", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
    glViewport(0, 0, WINDOW_SIZE, WINDOW_SIZE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    // set up anti-aliasing
    glEnable(GL_MULTISAMPLE);


    Fluid fluid(GRID_SIZE, GRID_SIZE, DT, VISCOSITY, DIFFUSION);
    fluid.init();

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    GLuint shaderProgram = createShaderProgram(VERTEX_SHADER, FRAGMENT_SHADER);
    
    double lastTime = glfwGetTime();
    int nbFrames = 0;

    while (!glfwWindowShouldClose(window)) {
        // Measure speed
        double currentTime = glfwGetTime();
        nbFrames++;
        if (currentTime - lastTime >= 1.0) { // If last print was more than 1 sec ago
            char title[256];
            sprintf(title, "Fluid Sim - %.2f ms/frame", 1000.0/double(nbFrames));
            glfwSetWindowTitle(window, title);
            nbFrames = 0;
            lastTime += 1.0;
        }

        static double prevMouseX = 0.0, prevMouseY = 0.0;
        static bool firstMouse = true;

        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) {
            double mouseX, mouseY;
            glfwGetCursorPos(window, &mouseX, &mouseY);
            mouseY = WINDOW_SIZE - mouseY; // Invert Y coordinate

            if (firstMouse) {
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                firstMouse = false;
            }

            float x = static_cast<float>(mouseX / SCALE);
            float y = static_cast<float>(mouseY / SCALE);

            if (x >= 1 && x < GRID_SIZE - 1 && y >= 1 && y < GRID_SIZE - 1) {
                float dx = static_cast<float>(mouseX - prevMouseX);
                float dy = static_cast<float>(mouseY - prevMouseY);
                fluid.add_force(x, y, dx * 5.0f, dy * 5.0f, 150.0f);
            }

            prevMouseX = mouseX;
            prevMouseY = mouseY;
        } else {
            firstMouse = true;
        }

        fluid.step();

        glClear(GL_COLOR_BUFFER_BIT);
        fluid.render(shaderProgram);
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
}