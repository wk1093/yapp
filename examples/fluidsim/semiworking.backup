#import std.math
#import std.io

#import <glad/glad.h>
#import <GLFW/glfw3.h>


const int GRID_SIZE = 64*1; // Grid resolution (64x64)
const float DT = 0.1f; // Time step
const float DIFFUSION = 0.00001f; // Diffusion rate
const float VISCOSITY = 0.0001f; // Viscosity
const int WINDOW_SIZE = 64*4; // Window size in pixels
const float SCALE = (float)(WINDOW_SIZE) / GRID_SIZE; // Scale factor for rendering

const char* VERTEX_SHADER = R"(#version 430 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTex;

out vec2 TexCoord;

void main() {
    TexCoord = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
)";

const char* FRAGMENT_SHADER =R"(#version 430 core
out vec4 FragColor;

in vec2 TexCoord;
uniform sampler2D uSimData; // RGBA32F: r=density, g=u, b=v, a=unused

// HSV to RGB conversion in GLSL
vec3 hsv2rgb(float h, float s, float v) {
    float c = v * s;
    float x = c * (1.0 - abs(mod(h / 60.0, 2.0) - 1.0));
    float m = v - c;
    float r, g, b;
    if (h < 60.0)      { r = c; g = x; b = 0.0; }
    else if (h < 120.0){ r = x; g = c; b = 0.0; }
    else if (h < 180.0){ r = 0.0; g = c; b = x; }
    else if (h < 240.0){ r = 0.0; g = x; b = c; }
    else if (h < 300.0){ r = x; g = 0.0; b = c; }
    else               { r = c; g = 0.0; b = x; }
    return vec3(r + m, g + m, b + m);
}

void main() {
    vec4 sim = texture(uSimData, TexCoord);
    float d = sim.r;
    float u = sim.g;
    float v = sim.b;
    float speed = sqrt(u * u + v * v);
    d = min(d, 255.0);
    speed = min(speed, 10.0);
    float curvedSpeed = sqrt(speed);
    float hue = mod(360.0 * 2.0 * (curvedSpeed / sqrt(10.0)), 360.0);
    float brightness = d / 255.0;
    float saturation = 1.0;
    vec3 rgb = hsv2rgb(hue, saturation, brightness);
    FragColor = vec4(rgb, 1.0);
}
)";

// Helper function to convert 2D grid indices to 1D array index
int IX(int x, int y) {
    x = math::max(0, math::min(x, GRID_SIZE - 1));
    y = math::max(0, math::min(y, GRID_SIZE - 1));
    return x + y * GRID_SIZE;
}

GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    int length = strlen(source);
    glShaderSource(shader, 1, &source, &length);
    glCompileShader(shader);

    // Check for errors
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        io::println(io::err, "Shader compilation failed: ", log);
    }

    return shader;
}

GLuint createShaderProgram(const char* vertexSrc, const char* fragmentSrc) {
    GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexSrc);
    GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentSrc);

    GLuint program = glCreateProgram();
    glAttachShader(program, vertShader);
    glAttachShader(program, fragShader);
    glLinkProgram(program);

    // Check for linking errors
    GLint success;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        char log[512];
        glGetProgramInfoLog(program, 512, nullptr, log);
        io::println(io::err, "Program linking failed: ", log);
    }

    glDeleteShader(vertShader);
    glDeleteShader(fragShader);

    return program;
}

const char* COMPUTE_ADD_FORCE_SHADER = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba32f) uniform image2D u_sim_tex;

uniform vec2 u_point;
uniform float u_radius;
uniform vec4 u_value; // r=density, g=velX, b=velY

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    float dist = distance(vec2(coord), u_point);

    if (dist < u_radius) {
        vec4 old_data = imageLoad(u_sim_tex, coord);
        float falloff = 1.0 - dist / u_radius;
        imageStore(u_sim_tex, coord, old_data + u_value * falloff);
    }
}
)";

const char* COMPUTE_ADVECT_SHADER = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_read_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

uniform float u_dt;
const float grid_size = 64.0;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(coord) / grid_size;
    
    vec2 vel = texture(u_read_tex, uv).gb;
    vec2 prev_pos = uv - (vel * u_dt / grid_size);
    
    vec4 advected_data = texture(u_read_tex, prev_pos);
    imageStore(u_write_tex, coord, advected_data);
}
)";

const char* COMPUTE_JACOBI_SHADER = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_x_tex;
layout(binding = 1) uniform sampler2D u_b_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

uniform float u_alpha;
uniform float u_beta_reciprocal;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(coord) / 64.0;
    vec2 texel_size = 1.0 / 64.0;

    vec4 x_l = texture(u_x_tex, uv - vec2(texel_size.x, 0));
    vec4 x_r = texture(u_x_tex, uv + vec2(texel_size.x, 0));
    vec4 x_t = texture(u_x_tex, uv + vec2(0, texel_size.y));
    vec4 x_b = texture(u_x_tex, uv - vec2(0, texel_size.y));
    vec4 b = texture(u_b_tex, uv);

    vec4 new_x = (b + u_alpha * (x_l + x_r + x_t + x_b)) * u_beta_reciprocal;
    imageStore(u_write_tex, coord, new_x);
}
)";

const char* COMPUTE_DIVERGENCE_SHADER = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_vel_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(coord) / 64.0;
    vec2 texel_size = 1.0 / 64.0;

    float v_l = texture(u_vel_tex, uv - vec2(texel_size.x, 0)).g;
    float v_r = texture(u_vel_tex, uv + vec2(texel_size.x, 0)).g;
    float v_t = texture(u_vel_tex, uv + vec2(0, texel_size.y)).b;
    float v_b = texture(u_vel_tex, uv - vec2(0, texel_size.y)).b;

    float divergence = 0.5 * (v_r - v_l + v_t - v_b);
    imageStore(u_write_tex, coord, vec4(divergence, 0, 0, 0));
}
)";

const char* COMPUTE_SUBTRACT_GRADIENT_SHADER = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0) uniform sampler2D u_vel_tex;
layout(binding = 1) uniform sampler2D u_pressure_tex;
layout(binding = 0, rgba32f) uniform writeonly image2D u_write_tex;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(coord) / 64.0;
    vec2 texel_size = 1.0 / 64.0;

    float p_l = texture(u_pressure_tex, uv - vec2(texel_size.x, 0)).r;
    float p_r = texture(u_pressure_tex, uv + vec2(texel_size.x, 0)).r;
    float p_t = texture(u_pressure_tex, uv + vec2(0, texel_size.y)).r;
    float p_b = texture(u_pressure_tex, uv - vec2(0, texel_size.y)).r;

    vec4 vel = texture(u_vel_tex, uv);
    vel.xy -= 0.5 * vec2(p_r - p_l, p_t - p_b);
    imageStore(u_write_tex, coord, vel);
}
)";

const char* COMPUTE_BOUNDARY_SHADER = R"(#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba32f) uniform image2D u_tex;
uniform int u_b;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(u_tex);

    if (coord.x > 0 && coord.x < size.x - 1 && coord.y > 0 && coord.y < size.y - 1) return;

    ivec2 inner_coord = clamp(coord, 1, size - 2);
    vec4 inner_val = imageLoad(u_tex, inner_coord);
    
    if (u_b == 1 && (coord.x == 0 || coord.x == size.x - 1)) {
        inner_val.g = -inner_val.g;
    }
    if (u_b == 2 && (coord.y == 0 || coord.y == size.y - 1)) {
        inner_val.b = -inner_val.b;
    }

    imageStore(u_tex, coord, inner_val);
}
)";


class Fluid {
public:
    GLuint sim_tex_a, sim_tex_b;
    GLuint pressure_tex_a, pressure_tex_b;
    GLuint advect_shader, jacobi_shader, divergence_shader, subtract_gradient_shader, boundary_shader, add_force_shader;

    Fluid() {
        init_textures();
        init_shaders();
    }

    void init_textures() {
        auto create_tex = []() {
            GLuint tex;
            glGenTextures(1, &tex);
            glBindTexture(GL_TEXTURE_2D, tex);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, GRID_SIZE, GRID_SIZE, 0, GL_RGBA, GL_FLOAT, nullptr);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            return tex;
        };
        sim_tex_a = create_tex();
        sim_tex_b = create_tex();
        pressure_tex_a = create_tex();
        pressure_tex_b = create_tex();
    }

    void init_shaders() {
        auto create_program = [](const char* src) {
            GLuint shader = glCreateShader(GL_COMPUTE_SHADER);
            glShaderSource(shader, 1, &src, nullptr);
            glCompileShader(shader);
            // Error checking...
            GLuint program = glCreateProgram();
            glAttachShader(program, shader);
            glLinkProgram(program);
            glDeleteShader(shader);
            return program;
        };
        advect_shader = create_program(COMPUTE_ADVECT_SHADER);
        jacobi_shader = create_program(COMPUTE_JACOBI_SHADER);
        divergence_shader = create_program(COMPUTE_DIVERGENCE_SHADER);
        subtract_gradient_shader = create_program(COMPUTE_SUBTRACT_GRADIENT_SHADER);
        boundary_shader = create_program(COMPUTE_BOUNDARY_SHADER);
        add_force_shader = create_program(COMPUTE_ADD_FORCE_SHADER);
    }

    void swap_sim_textures() { std::swap(sim_tex_a, sim_tex_b); }
    void swap_pressure_textures() { std::swap(pressure_tex_a, pressure_tex_b); }

    void dispatch(GLuint shader, int w, int h) {
        glUseProgram(shader);
        glDispatchCompute(w / 8, h / 8, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
    }

    void add_force(float x, float y, float dx, float dy, float density) {
        glUseProgram(add_force_shader);
        glBindImageTexture(0, sim_tex_a, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        glUniform2f(glGetUniformLocation(add_force_shader, "u_point"), x, y);
        glUniform1f(glGetUniformLocation(add_force_shader, "u_radius"), 5.0f);
        glUniform4f(glGetUniformLocation(add_force_shader, "u_value"), density, dx, dy, 0.0f);
        dispatch(add_force_shader, GRID_SIZE, GRID_SIZE);
    }

    void advect() {
        glUseProgram(advect_shader);
        glBindImageTexture(0, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1f(glGetUniformLocation(advect_shader, "u_dt"), DT);
        dispatch(advect_shader, GRID_SIZE, GRID_SIZE);
        swap_sim_textures();
    }

    void diffuse(float rate) {
        float alpha = (GRID_SIZE * GRID_SIZE) / (rate * DT);
        glUseProgram(jacobi_shader);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_alpha"), alpha);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_beta_reciprocal"), 1.0f / (4.0f + alpha));
        
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a); // b texture
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_b_tex"), 1);

        glActiveTexture(GL_TEXTURE0);
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_x_tex"), 0);

        for (int i = 0; i < 20; ++i) {
            glBindImageTexture(0, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
            glBindTexture(GL_TEXTURE_2D, sim_tex_a);
            dispatch(jacobi_shader, GRID_SIZE, GRID_SIZE);
            swap_sim_textures();
        }
    }

    void project() {
        // Calculate divergence
        glUseProgram(divergence_shader);
        glBindImageTexture(0, pressure_tex_a, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        dispatch(divergence_shader, GRID_SIZE, GRID_SIZE);

        // Solve for pressure
        glUseProgram(jacobi_shader);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_alpha"), -GRID_SIZE * GRID_SIZE);
        glUniform1f(glGetUniformLocation(jacobi_shader, "u_beta_reciprocal"), 1.0f / 4.0f);
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, pressure_tex_a); // b texture
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_b_tex"), 1);
        glActiveTexture(GL_TEXTURE0);
        glUniform1i(glGetUniformLocation(jacobi_shader, "u_x_tex"), 0);

        for (int i = 0; i < 20; ++i) {
            glBindImageTexture(0, pressure_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
            glBindTexture(GL_TEXTURE_2D, pressure_tex_a);
            dispatch(jacobi_shader, GRID_SIZE, GRID_SIZE);
            swap_pressure_textures();
        }

        // Subtract gradient
        glUseProgram(subtract_gradient_shader);
        glBindImageTexture(0, sim_tex_b, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glUniform1i(glGetUniformLocation(subtract_gradient_shader, "u_vel_tex"), 0);
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, pressure_tex_a);
        glUniform1i(glGetUniformLocation(subtract_gradient_shader, "u_pressure_tex"), 1);
        dispatch(subtract_gradient_shader, GRID_SIZE, GRID_SIZE);
        swap_sim_textures();
    }

    void step() {
        advect();
        diffuse(VISCOSITY);
        project();
    }

    void render() {
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, sim_tex_a);
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    }
};

int main(vec<str> args) {
    if (!glfwInit()) {
        return -1;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
    glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4x MSAA

    GLFWwindow* window = glfwCreateWindow(WINDOW_SIZE, WINDOW_SIZE, "Fluid Sim", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
    glViewport(0, 0, WINDOW_SIZE, WINDOW_SIZE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    // set up anti-aliasing
    glEnable(GL_MULTISAMPLE);


    float quad[] = {
    -1.0f,  1.0f,  0.0f, 1.0f,
    -1.0f, -1.0f,  0.0f, 0.0f,
     1.0f,  1.0f,  1.0f, 1.0f,
     1.0f, -1.0f,  1.0f, 0.0f,
};

GLuint VAO, VBO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);

glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(quad), quad, GL_STATIC_DRAW);

glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
glEnableVertexAttribArray(1);

    Fluid fluid;

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    GLuint shaderProgram = createShaderProgram(VERTEX_SHADER, FRAGMENT_SHADER);
    glUseProgram(shaderProgram);
    // Bind simTexID to texture unit 0 and set uniform
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, fluid.sim_tex_a);
    GLint loc = glGetUniformLocation(shaderProgram, "uSimData");
    glUniform1i(loc, 0);

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();

static double prevMouseX = 0.0, prevMouseY = 0.0;

if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) {
    double mouseX, mouseY;
    glfwGetCursorPos(window, &mouseX, &mouseY);
    mouseY = WINDOW_SIZE - mouseY; // Invert Y coordinate

    float x = mouseX / SCALE;
    float y = mouseY / SCALE;

    if (x >= 1 && x < GRID_SIZE - 1 && y >= 1 && y < GRID_SIZE - 1) {
        float dx = static_cast<float>(mouseX - prevMouseX);
        float dy = static_cast<float>(mouseY - prevMouseY);

        const float maxSpeed = 10.0f;
        float len = math::sqrt(dx * dx + dy * dy);
        if (len > maxSpeed) {
            dx = dx / len * maxSpeed;
            dy = dy / len * maxSpeed;
        }

        const float densityStrength = 300.0f;
        const float velocityStrength = 15.0f;
        
        fluid.add_force(x, y, dx * velocityStrength, dy * velocityStrength, densityStrength);
    }

    prevMouseX = mouseX;
    prevMouseY = mouseY;
} else {
    glfwGetCursorPos(window, &prevMouseX, &prevMouseY);
}

        fluid.step();
        glClear(GL_COLOR_BUFFER_BIT);
        glBindVertexArray(VAO);
        
        glUseProgram(shaderProgram);
        fluid.render();

        glfwSwapBuffers(window);
    }

    glfwDestroyWindow(window);
glfwTerminate();

    return 0;
}