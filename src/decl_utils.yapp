#import std.alg

#import <clang-c/Index.h>

struct pub DeclInfo {
    str name;
    str usr;
    str code;
    str annotation;
    bool isDefinition = false;
    bool isInline = false;
    bool isExternC = false;
    bool isTemplate = false;
    bool isStatic = false;
    bool isExtern = false;
    bool isConstexpr = false; // For C++20 constexpr variables
    bool isConst = false;
    bool isUsingDec = false; // For using declarations
    CXCursorKind kind;
    int sourceOrderIndex = 0;
    vec<str> namespaces;
    str typeUsr;
};

pub bool isExternC(CXCursor cursor) {
    if (clang_getCursorKind(cursor) != CXCursor_FunctionDecl)
        return false;
    if (clang_getCursorLinkage(cursor) != CXLinkage_External)
        return false;
    CXCursor parent = clang_getCursorSemanticParent(cursor);
    if (clang_getCursorKind(parent) == CXCursor_LinkageSpec) {
        CXSourceRange range = clang_getCursorExtent(parent);
        CXTranslationUnit tu = clang_Cursor_getTranslationUnit(parent);
        CXToken* tokens = nullptr;
        unsigned numTokens = 0;
        clang_tokenize(tu, range, &tokens, &numTokens);
        for (unsigned i = 0; i < numTokens; ++i) {
            CXString spelling = clang_getTokenSpelling(tu, tokens[i]);
            const char* token = clang_getCString(spelling);
            if (strcmp(token, "\"C\"") == 0) {
                clang_disposeString(spelling);
                clang_disposeTokens(tu, tokens, numTokens);
                return true;
            }
            clang_disposeString(spelling);
        }
        clang_disposeTokens(tu, tokens, numTokens);
    }
    return false;
}

pub bool isAnonymousStruct(const DeclInfo& d) {
    return (d.kind == CXCursor_StructDecl) && d.name.empty();
}

pub str toStdString(CXString cxStr) {
    str str = clang_getCString(cxStr);
    clang_disposeString(cxStr);
    return str;
}

extern str GLOBAL_INPUT_FILE;
extern str GLOBAL_SOURCE_FILE;

pub str createLineDirective(CXSourceLocation loc) {
    CXFile file;
    unsigned line, column, offset;
    clang_getFileLocation(loc, &file, &line, &column, &offset);
    CXString fileName = clang_getFileName(file);
    str filePath = toStdString(fileName);
    clang_disposeString(fileName);
    // replace input file with source file
    if (filePath == GLOBAL_INPUT_FILE) {
        filePath = GLOBAL_SOURCE_FILE;
    }
    // create a #line directive for the file and line number
    str lineDirective = "\n#line " + str::from(line) + " \"" + filePath + "\"\n";

    return lineDirective;
}

pub bool isDifferentDirective(CXSourceLocation loc1, CXSourceLocation loc2) {
    CXFile file1, file2;
    unsigned line1, line2, column1, column2, offset1, offset2;
    clang_getFileLocation(loc1, &file1, &line1, &column1, &offset1);
    clang_getFileLocation(loc2, &file2, &line2, &column2, &offset2);
    return (file1 != file2 || line1 != line2);
}

pub str getSourceText(CXCursor cursor, CXTranslationUnit tu) {
    CXSourceRange range = clang_getCursorExtent(cursor);
    CXToken* tokens = nullptr;
    unsigned numTokens = 0;
    // get location to create a #line directive
    CXSourceLocation loc = clang_getCursorLocation(cursor);
    // tokenize the range
    clang_tokenize(tu, range, &tokens, &numTokens);
    str result = createLineDirective(loc);
    for (unsigned i = 0; i < numTokens; ++i) {
        CXSourceLocation tokenLoc = clang_getTokenLocation(tu, tokens[i]);
        if (isDifferentDirective(loc, tokenLoc)) {
            result += createLineDirective(tokenLoc);
        }
        loc = tokenLoc;
        result += toStdString(clang_getTokenSpelling(tu, tokens[i]));
        result += " ";
    }
    clang_disposeTokens(tu, tokens, numTokens);
    return result;
}

pub str getAnnotate(CXCursor cursor) {
    str annotation = "";
    clang_visitChildren(cursor, [](CXCursor c, CXCursor, CXClientData data) {
        if (clang_getCursorKind(c) == CXCursor_AnnotateAttr) {
            auto stri = toStdString(clang_getCursorSpelling(c));
            *static_cast<str*>(data) = stri;
            return CXChildVisit_Break;
        }
        return CXChildVisit_Continue;
    }, &annotation);
    return annotation;
}

pub vec<str> getNamespaceChain(CXCursor cursor) {
    vec<str> chain;
    CXCursor parent = clang_getCursorSemanticParent(cursor);
    while (!clang_Cursor_isNull(parent) && clang_getCursorKind(parent) != CXCursor_TranslationUnit) {
        if (clang_getCursorKind(parent) == CXCursor_Namespace) {
            str ns = toStdString(clang_getCursorSpelling(parent));
            chain.push_back(ns);
        }
        parent = clang_getCursorSemanticParent(parent);
    }
    alg::reverse(chain);
    return chain;
}

pub str makeDeclaration(const str& code) {
    str trimmed = code;
    trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
    size_t brace = trimmed.find('{');
    if (brace != str::npos) {
        trimmed = trimmed.substr(0, brace);
    }
    if (trimmed.back() != ';') {
        trimmed += ";";
    }
    return trimmed;
}
