#import std.io
#import std.regex
#import std.fs

#import file_writer
#import visitor

pub vec<str> preprocStored;
pub vec<str> usingStored;

pub str prePreprocess(const str& inputFile, const str& outputDir, bool stdlib) {
    file::reader in(inputFile);
    if (!in) {
        io::println(io::err, "Failed to open input file for pre-preprocessing: ", inputFile);
        exit(1);
    }
    str::writer out;
    str line;

    if (stdlib) {
        preprocStored.push_back("include \"std.main.yapp.h\"\n#include \"std.str.yapp.h\"\n#include \"std.vec.yapp.h\"\n#include \"std.result.yapp.h\"\n#include \"std.stream.yapp.h\"\n");
        out << "pub __attribute__((annotate(\"__pub_preproc__\"))) void __pub_preproc__0();";
    }
    

    regex::re pubPreproc(R"(^\s*#pub\s+(.*?)$)");
    regex::re importPreproc(R"(^\s*#import\s+(.*?)$)");
    regex::re usingDefRegex(R"(^\s*#using\s+(.*?)$)");
        while (line.getline(in)) {
        regex::result m;
        if (regex::search(line, m, pubPreproc)) {
            preprocStored.push_back(m[1].str());
            out << "pub __attribute__((annotate(\"__pub_preproc__\"))) void __pub_preproc__" << preprocStored.size() - 1 << "();\n";
        } else if (regex::search(line, m, importPreproc)) {
            str importedFile = m[1].str();
            // if it is "something.yapp" or <something.yapp> we need to convert it to "something.yapp.h" or <something.yapp.h>
            
            bool angledQuotes = (importedFile[0] == '<' && importedFile[importedFile.size() - 1] == '>');
            bool doubleQuotes = (importedFile[0] == '"' && importedFile[importedFile.size() - 1] == '"');
            if (angledQuotes || doubleQuotes) {
                // Remove the angled or double quotes
                importedFile = importedFile.substr(1, importedFile.size() - 2);
            }
            if (importedFile.find(".yapp") != str::npos) {
                importedFile = importedFile.substr(0, importedFile.find_last_of('.')) + ".yapp.h";
            }
            if (angledQuotes) {
                importedFile = "<" + importedFile + ">";
            } else if (doubleQuotes) {
                importedFile = "\"" + importedFile + "\"";
            } else {
                importedFile = "\"" + importedFile + ".yapp.h\"";
            }
            
            preprocStored.push_back("include " + importedFile);
            out << "pub __attribute__((annotate(\"__pub_preproc__\"))) void __pub_preproc__" << preprocStored.size() - 1 << "();\n";
        } else if (regex::search(line, m, usingDefRegex)) {
            // We found a #using directive
            // We need to add it to the usingStored vector
            out << "pub __attribute__((annotate(\"__pub_using_alias__\"))) void __pub_using_alias__" << usingStored.size() << "();\n";

            usingStored.push_back(m[1].str());
        } else {
            out << line << "\n";
        }
    }
    str outFile = fs::path(outputDir.stdstr()) / (inputFile.substr(inputFile.find_last_of("/\\") + 1) + ".pp0");
    file::writer p0f(outFile);
    if (!p0f) {
        io::println(io::err, "Failed to write pre-preprocessed file: ", outFile);
        exit(1);
    }
    p0f << out.str();
    p0f.close();
    return outFile;
}

pub str preprocessStep2(const str& p0File, const str& outputDir) {
    // str::writer out;
    // str line;

    // also doesn't need to be at the start of the line
    regex::re usingNamespaceFix(R"((pub|priv)?\s*using\s+namespace\s+([a-zA-Z_][a-zA-Z0-9_:]*);)");
    regex::re usingAliasFix(R"((template\s*\<.*?\>\s*)?(pub|priv)?\s*using\s+([a-zA-Z_][a-zA-Z0-9_:<>, ]*)\s*(=\s*([a-zA-Z_][a-zA-Z0-9_:<>, ]*)\s*)?;)");

    str content = io::fileReadText(p0File).unwrap();

    regex::result m;
    str result;
    str::const_iterator searchStart = content.cbegin();

    while (regex::search(searchStart, content.cend(), m, usingNamespaceFix)) {
        // Append the part before the match
        result.append(searchStart, m[0].first);

        str attr = m[1].str();         // "pub" or "priv"
        str namespaceName = m[2].str();

        // Build the replacement
        if (attr.empty()) {
            result += "\nnamespace " + namespaceName + " {};using namespace " + namespaceName + ";\n";
        } else {
            result += "\nnamespace " + namespaceName + " {};" + attr + " using namespace " + namespaceName + ";\n";
        }

        // Move past this match
        searchStart = m[0].second;
    }

    // Append the remaining part
    result.append(searchStart, content.cend());
    content = move(result);

    // Fix using alias directives
    while (regex::search(content, m, usingAliasFix)) {
        // For some reason libclang like to just remove using aliases sometimes, so we will just
        // add them back at the end
        // This is very similar to the pub preproc where it is a fake function declaration
        usingStored.push_back(m[0].str());
        content = regex::replace(content, usingAliasFix, "\npub __attribute__((annotate(\"__pub_using_alias__\"))) void __pub_using_alias__" + str::from(usingStored.size() - 1) + "();\n", regex::format_first_only);
    }
    str outFile = fs::path(outputDir.stdstr()) / (p0File.substr(p0File.find_last_of("/\\") + 1) + ".pp1");
    file::writer p1f(outFile);
    if (!p1f) {
        io::println(io::err, "Failed to write second preprocessed file: ", outFile);
        exit(1);
    }
    p1f << content;
    p1f.close();
    return outFile;
}

pub void postProcess(const str& headerFile) {
    file::reader in(headerFile);
    if (!in) {
        io::println(io::err, "Failed to open input header file for post-processing: ", headerFile);
        exit(1);
    }
    str::writer out;
    str line;
    regex::re usingAliasRegex(R"(__attribute__\s*\(\s*\(\s*annotate\s*\(\s*"pub"\s*\)\s*\)\s*\)\s*__attribute__\s*\(\s*\(\s*annotate\s*\(\s*"__pub_using_alias__"\s*\)\s*\)\s*\)\s*void\s+__pub_using_alias__(\d+)\s*\(\s*\)\s*;)");
    while (line.getline(in)) {
        regex::result m;
        if (regex::search(line, m, usingAliasRegex)) {
            // We found a using alias declaration
            // We need to replace it with the actual using alias from usingStored
            int index = str::toInt(m[1].str());
            if (index < 0 || index >= usingStored.size()) {
                io::println(io::err, "Error: Using alias index out of bounds: ", index);
                exit(1);
            }
            out << usingStored[index] << "\n"; // Replace with the actual using alias
        } else {
            out << line << "\n"; // Keep the line as is
        }
    }

    in.close();

    file::writer outFileStream(headerFile);
    if (!outFileStream) {
        io::println(io::err, "Failed to write post-processed header file: ", headerFile);
        exit(1);
    }
    outFileStream << out.str();
    outFileStream.close();
}

priv const char* usageString = R"(
Usage: yappc <source.yapp> [OPTIONS] -- [Preprocessor Args] -- [Compiler Args]
Options:
    -s          Toggle whether the source file is left in the output. This is useful for debugging.
    -g          Show generated intermediate preprocessing files.
    -h          Show this help message
    -o <output> Specify output folder for generated files (default: same as input file)
    -r          Remove the header from the generated .yapp.cpp file (not very useful)
    -c          Compile the generated files.
    --          Separator for different argument sections
Preprocessor Args:
    These arguments are passed directly to the preprocessor (clang -E).
    You can use -D to define macros, e.g., -DDEBUG=1.
Compiler Args:
    These arguments are passed directly to the compiler (clang++).
    You can use -o to specify the output file.
)";

str GLOBAL_SOURCE_FILE;
str GLOBAL_INPUT_FILE;

pub int main(vec<str> argv) {
    int argc = argv.size();
    if (argc < 2) {
        io::println(io::err, "Usage: ./yappc <source.yapp> [OPTIONS] -- [Preprocessor Args] -- [Compiler Args]");
        return 1;
    }

    vec<str> preprocArgs;
    vec<str> compileArgs;
    vec<str> myArgs;

    int argState = 0; // 0: myargs, 1: preprocArgs, 2: compileArgs
    for (int i = 2; i < argc; ++i) {
        if (argv[i] == "--") {
            argState++;
            continue;
        }
        if (argState == 0) {
            myArgs.push_back(argv[i]);
        } else if (argState == 1) {
            preprocArgs.push_back(argv[i]);
        } else if (argState == 2) {
            compileArgs.push_back(argv[i]);
        }
    }
    // Check for -d option in myArgs
    bool debugMode = false;
    bool sourceToggle = false;
    bool removeHeader = false;
    bool compileGenerated = false;
    bool useStdlib = true;
    str outputDir = ""; // Default to same directory as input file
    for (int i = 0; i < myArgs.size(); i++) {
        str arg = myArgs[i];
        if (arg == "-s") {
            sourceToggle = true;
        }
        if (arg == "-g") {
            debugMode = true;
        }
        if (arg == "-h") {
            io::print(usageString);
            return 0;
        }
        if (arg == "-o") {
            // Handle output directory option
            if (i + 1 >= myArgs.size()) {
                // If -o is the last argument, we can't set an output directory
                io::println(io::err, "Error: -o option requires a directory argument.");
                return 1; 
            } else if (myArgs[i + 1][0] == '-') {
                // If the next argument is another option, we can't set an output directory
                io::println(io::err, "Error: -o option requires a directory argument.");
                return 1;
            } else {
                outputDir = myArgs[i + 1];
                i++; // Skip the next argument since it's the directory
                fs::path dirPath(outputDir.stdstr());
                if (!fs::exists(dirPath)) {
                    io::println(io::err, "Warning: Specified output directory does not exist. Creating: ", outputDir);
                    fs::create_directories(dirPath);
                }
            }
        }
        if (arg == "-r") {
            // Handle remove header option
            removeHeader = true;
        }
        if (arg == "-c") {
            // Handle compile generated files option
            compileGenerated = true;
        }
        if (arg == "--no-std" || arg == "--no-stdlib") {
            // Disable stdlib usage
            useStdlib = false;
        }
    }

    str base = argv[1];
    size_t slash = base.find_last_of("/\\");
    size_t dot = base.find_last_of('.');
    str filename = base.substr(slash == str::npos ? 0 : slash + 1, dot - (slash == str::npos ? 0 : slash + 1));
    str dir = (slash == str::npos) ? "./" : base.substr(0, slash + 1);
    if (outputDir.empty()) {
        outputDir = dir; // Default to same directory as input file
    }


    // pre-preprocessor step
    str step0File = prePreprocess(argv[1], outputDir, useStdlib);
    str step1File = preprocessStep2(step0File, outputDir);
    // preprocessor step
    str preprocOutputFile = step1File;

    preprocOutputFile = preprocOutputFile.substr(0, preprocOutputFile.size() - 2) + ".pp2"; // Change extension to .yapp.cpp for the preprocessed output
    str preprocCommand = "clang -E ";
    for (const auto& arg : preprocArgs) {
        preprocCommand += "\"" + arg + "\" ";
    }
    preprocCommand += "\"-Dpub=__attribute__((annotate(\\\"pub\\\")))\" ";
    preprocCommand += "\"-Dpriv=__attribute__((annotate(\\\"priv\\\")))\" ";
    preprocCommand += "-D__yaplusplus ";
    preprocCommand += "-x c++ \"" + step1File + "\" > \"" + preprocOutputFile + "\"";
    if (system(preprocCommand.c_str()) != 0) {
        io::println(io::err, "Preprocessing failed. Check the preprocessor arguments and input file.");
        return 1;
    }

    file::reader preprocFile(preprocOutputFile);
    if (!preprocFile) {
        io::println(io::err, "Failed to open preprocessed file: ", preprocOutputFile);
        return 1;
    }
    str line;
    str::writer cleanedOutput;
    while (line.getline(preprocFile)) {
        if (line.empty() || line[0] != '#') {
            cleanedOutput << line << "\n";
        }
    }
    preprocFile.close();
    file::writer cleanedFile(preprocOutputFile);
    if (!cleanedFile) {
        io::println(io::err, "Failed to write cleaned preprocessed file: ", preprocOutputFile);
        return 1;
    }
    cleanedFile << cleanedOutput.str();
    cleanedFile.close();

    CXIndex index = clang_createIndex(0, 0);
    const char* args[] = {
        "-x", "c++-cpp-output",
        "-std=c++20",
        "-Dpub=__attribute__((annotate(\"pub\")))",
        "-Dpriv=__attribute__((annotate(\"priv\")))",
        "-P"
    };

    GLOBAL_SOURCE_FILE = argv[1];
    GLOBAL_INPUT_FILE = preprocOutputFile.c_str();

    CXTranslationUnit tu = clang_parseTranslationUnit(
        index, preprocOutputFile.c_str(), args, sizeof(args)/sizeof(args[0]), nullptr, 0, CXTranslationUnit_Incomplete);
    if (!tu) {
        if (unsigned numErrors = clang_getNumDiagnostics(tu)) {
            unsigned displayOptions = clang_defaultDiagnosticDisplayOptions();
            for (unsigned i=0; i < numErrors; ++i) {
                CXDiagnostic diag = clang_getDiagnostic(tu, i);
                CXString str = clang_formatDiagnostic(diag, displayOptions);
                io::println(io::err, clang_getCString(str));
                clang_disposeString(str);
                clang_disposeDiagnostic(diag);
            }
            return 2;
        }
        io::println(io::err, "Failed to parse input file: ", preprocOutputFile);
        return 1;
    }

    CXCursor root = clang_getTranslationUnitCursor(tu);
    clang_visitChildren(root, visitor, &tu);

    writeFiles(filename, outputDir);
    clang_disposeTranslationUnit(tu);
    clang_disposeIndex(index);

    // Post-process the header file if it was generated
    str headerFile = fs::path(outputDir.stdstr()) / (filename + ".yapp.h");
    postProcess(headerFile);

    if (compileGenerated) {
        io::println("WARNING: Auto compiling generated files is not recommended. Use with caution.");
        str outdirfilename = fs::path(outputDir.stdstr()) / (filename + ".yapp.cpp");
        str compileCommand = "clang++ \"" + outdirfilename + "\" ";
        for (const auto& arg : compileArgs) {
            compileCommand += "\"" + arg + "\" ";
        }
        if (system(compileCommand.c_str()) != 0) {
            io::println(io::err, "Compilation failed.");
            return 1;
        }
    }

    if (!debugMode) {
        // remove intermediate files
        fs::remove(preprocOutputFile.c_str());
        fs::remove(step1File.c_str());
        fs::remove(step0File.c_str());

        if ((!compileGenerated && sourceToggle) || (compileGenerated && !sourceToggle)) {
            fs::remove((fs::path(outputDir.stdstr()) / (filename + ".yapp.cpp")).c_str());
        }

        if (removeHeader) {
            fs::remove((fs::path(outputDir.stdstr()) / (filename + ".yapp.h")).c_str());
        }
    }

    return 0;
}