#include "file_writer.yapp.h"

#define pub
#define priv

__attribute__ ( ( annotate ( "priv" ) ) ) void emitWithNamespaces ( std :: ostream & out , const std :: vector < DeclInfo > & decls ) { out << "// Emitted by yappc\n" ; out << "// Emitting " << decls . size ( ) << " declarations\n\n" ; std :: vector < std :: string > currentNS ; bool inExternC = false ; for ( size_t idx = 0 ; idx < decls . size ( ) ; ++ idx ) { const auto & d = decls [ idx ] ; size_t common = 0 ; while ( common < currentNS . size ( ) && common < d . namespaces . size ( ) && currentNS [ common ] == d . namespaces [ common ] ) { ++ common ; } if ( inExternC && ( currentNS . size ( ) != common || d . namespaces . size ( ) != common ) ) { out << "#ifdef __cplusplus\n}\n#endif\n" ; inExternC = false ; } for ( size_t i = currentNS . size ( ) ; i -- > common ; ) { out << "}\n" ; } for ( size_t i = common ; i < d . namespaces . size ( ) ; ++ i ) { out << "namespace " << d . namespaces [ i ] << " {\n" ; } currentNS = d . namespaces ; if ( d . isExternC && ! inExternC ) { out << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n" ; inExternC = true ; } out << d . code << ";\n\n" ; bool nextNeedsExtern = false ; size_t nextCommon = common ; if ( idx + 1 < decls . size ( ) ) { const auto & next = decls [ idx + 1 ] ; nextCommon = 0 ; while ( nextCommon < currentNS . size ( ) && nextCommon < next . namespaces . size ( ) && currentNS [ nextCommon ] == next . namespaces [ nextCommon ] ) { ++ nextCommon ; } nextNeedsExtern = next . isExternC ; } if ( inExternC && ( idx + 1 == decls . size ( ) || currentNS . size ( ) != nextCommon || ! nextNeedsExtern ) ) { out << "#ifdef __cplusplus\n}\n#endif\n" ; inExternC = false ; } } for ( size_t i = currentNS . size ( ) ; i -- > 0 ; ) { out << "}\n" ; } } ;

__attribute__ ( ( annotate ( "priv" ) ) ) std :: vector < DeclInfo > collectUniqueDecls ( ) { std :: vector < DeclInfo > seen ; std :: unordered_map < std :: string , size_t > usrToIndex ; for ( auto & d : decls ) { if ( d . annotation . empty ( ) ) { std :: cout << "Warning: Declaration without annotation for " << d . name << "\n" ; d . annotation = "priv" ; } auto it = usrToIndex . find ( d . usr ) ; if ( it == usrToIndex . end ( ) ) { usrToIndex [ d . usr ] = seen . size ( ) ; seen . push_back ( d ) ; } else { auto & existing = seen [ it -> second ] ; if ( existing . annotation == "priv" && d . annotation == "pub" ) { existing = d ; } else if ( ! existing . isDefinition && d . isDefinition ) { } } } std :: sort ( seen . begin ( ) , seen . end ( ) , [ ] ( const DeclInfo & a , const DeclInfo & b ) { return a . sourceOrderIndex < b . sourceOrderIndex ; } ) ; return seen ; } ;

__attribute__ ( ( annotate ( "priv" ) ) ) bool isGlobalVariable ( const DeclInfo & d ) { return ! d . isStatic && ! isAnonymousStruct ( d ) && d . kind == CXCursor_VarDecl && d . namespaces . empty ( ) ; } ;

template < typename T > __attribute__ ( ( annotate ( "priv" ) ) ) bool isAnonymousTypeCursor ( T cursor ) { if ( ! clang_Cursor_isNull ( cursor ) ) { CXString spelling = clang_getCursorSpelling ( cursor ) ; bool anon = ! clang_getCString ( spelling ) || ! * clang_getCString ( spelling ) ; clang_disposeString ( spelling ) ; CXCursorKind kind = clang_getCursorKind ( cursor ) ; if ( anon && ( kind == CXCursor_StructDecl || kind == CXCursor_UnionDecl || kind == CXCursor_EnumDecl ) ) { return true ; } } return false ; } ;

__attribute__ ( ( annotate ( "priv" ) ) ) bool isAnonymousType ( const DeclInfo & d ) { if ( d . typeUsr . empty ( ) ) { return false ; } if ( std :: find ( anonymousTypes . begin ( ) , anonymousTypes . end ( ) , d . typeUsr ) != anonymousTypes . end ( ) ) { return true ; } return false ; } ;

__attribute__ ( ( annotate ( "priv" ) ) ) extern std :: vector < std :: string > preprocStored ;

__attribute__ ( ( annotate ( "priv" ) ) ) std :: vector < DeclInfo > collectHeaderDecls ( const std :: vector < DeclInfo > & seen ) { std :: vector < DeclInfo > pubDecls ; for ( const auto & d : seen ) { if ( d . annotation == "pub" && d . name . find ( "__pub_preproc__" ) == 0 ) { size_t index = std :: stoul ( d . name . substr ( strlen ( "__pub_preproc__" ) ) ) ; if ( index >= preprocStored . size ( ) ) { std :: cerr << "Warning: __pub_preproc__ index out of bounds: " << index << "\n" ; continue ; } DeclInfo copy = d ; copy . code = "#" + preprocStored [ index ] + "\n" ; pubDecls . push_back ( copy ) ; continue ; } if ( d . isStatic && ! d . isUsingDec ) continue ; if ( d . annotation == "pub" ) { if ( isAnonymousStruct ( d ) ) { continue ; } if ( ( ( d . kind == CXCursor_StructDecl || d . kind == CXCursor_UnionDecl || d . kind == CXCursor_EnumDecl ) && typedefBackedTags . count ( d . usr ) ) && ! d . isUsingDec ) { continue ; } DeclInfo copy = d ; if ( ! d . isTemplate && ! d . isConstexpr && d . isDefinition && ! d . isInline && ( d . kind == CXCursor_FunctionDecl || d . kind == CXCursor_CXXMethod ) ) { copy . code = makeDeclaration ( d . code ) ; } if ( isGlobalVariable ( d ) && ! d . isUsingDec ) { if ( isAnonymousType ( d ) ) { continue ; } if ( ! d . isConstexpr && ! d . isExtern ) { std :: string code = d . code ; size_t eq = code . find ( '=' ) ; if ( eq != std :: string :: npos ) code = code . substr ( 0 , eq ) ; code . erase ( 0 , code . find_first_not_of ( " \t\n\r" ) ) ; code . erase ( code . find_last_not_of ( " \t\n\r" ) + 1 ) ; if ( ! code . empty ( ) && code . back ( ) == ';' ) code . pop_back ( ) ; copy . code = "extern \n" + code ; } } pubDecls . push_back ( copy ) ; } } std :: sort ( pubDecls . begin ( ) , pubDecls . end ( ) , [ ] ( const DeclInfo & a , const DeclInfo & b ) { return a . sourceOrderIndex < b . sourceOrderIndex ; } ) ; return pubDecls ; } ;

__attribute__ ( ( annotate ( "priv" ) ) ) std :: vector < DeclInfo > collectSourceDecls ( const std :: vector < DeclInfo > & seen ) { std :: unordered_map < std :: string , bool > pubHasDefinition ; for ( const auto & d : seen ) { if ( d . annotation == "pub" && d . isDefinition ) { pubHasDefinition [ d . name ] = true ; } } std :: vector < DeclInfo > sourceDecls ; for ( const auto & d : decls ) { if ( d . annotation . empty ( ) ) { const_cast < DeclInfo & > ( d ) . annotation = "priv" ; } if ( d . kind == CXCursor_TypedefDecl || d . kind == CXCursor_TypeAliasDecl || d . kind == CXCursor_StructDecl || d . kind == CXCursor_EnumDecl || d . kind == CXCursor_UnionDecl || d . kind == CXCursor_ClassDecl ) { continue ; } if ( isAnonymousStruct ( d ) ) continue ; if ( isGlobalVariable ( d ) && d . annotation == "priv" ) { sourceDecls . push_back ( d ) ; continue ; } if ( d . annotation == "pub" ) { if ( d . isTemplate ) continue ; if ( d . isConstexpr ) continue ; if ( ! d . isDefinition && pubHasDefinition [ d . name ] ) continue ; if ( d . isInline ) continue ; if ( ! d . isDefinition ) continue ; if ( d . kind == CXCursor_FunctionDecl || d . kind == CXCursor_CXXMethod ) { size_t start = d . code . find ( '(' , d . code . find ( d . name ) ) ; int parenCount = 1 ; size_t end = start + 1 ; while ( end < d . code . size ( ) && parenCount > 0 ) { if ( d . code [ end ] == '(' ) { ++ parenCount ; } else if ( d . code [ end ] == ')' ) { -- parenCount ; } ++ end ; } std :: string params = d . code . substr ( start + 1 , end - start - 2 ) ; if ( parenCount == 0 && ! params . empty ( ) && params . find ( '=' ) != std :: string :: npos ) { std :: cout << "Removing default parameters from function: " << d . name << params << "\n" ; size_t pos = params . find ( '=' ) ; while ( pos != std :: string :: npos ) { size_t nextComma = params . find ( ',' , pos ) ; if ( nextComma == std :: string :: npos ) { params . erase ( pos ) ; break ; } else { params . erase ( pos , nextComma - pos + 1 ) ; } pos = params . find ( '=' , pos ) ; } std :: string newCode = d . code . substr ( 0 , start + 1 ) + params + d . code . substr ( end - 1 ) ; const_cast < DeclInfo & > ( d ) . code = newCode ; } } } sourceDecls . push_back ( d ) ; } std :: sort ( sourceDecls . begin ( ) , sourceDecls . end ( ) , [ ] ( const DeclInfo & a , const DeclInfo & b ) { return a . sourceOrderIndex < b . sourceOrderIndex ; } ) ; return sourceDecls ; } ;

__attribute__ ( ( annotate ( "pub" ) ) ) void writeFiles ( const std :: string & base , const std :: string & dir ) { std :: ofstream hfile ( std :: filesystem :: path ( dir ) / ( base + ".yapp.h" ) ) ; std :: ofstream cppfile ( std :: filesystem :: path ( dir ) / ( base + ".yapp.cpp" ) ) ; hfile << "#pragma once\n" ; hfile << "#define pub\n#define priv\n\n" ; cppfile << "#include \"" << base << ".yapp.h\"\n\n" ; cppfile << "#define pub\n#define priv\n\n" ; auto seen = collectUniqueDecls ( ) ; auto pubDecls = collectHeaderDecls ( seen ) ; emitWithNamespaces ( hfile , pubDecls ) ; hfile << "#undef pub\n#undef priv\n" ; auto sourceDecls = collectSourceDecls ( seen ) ; emitWithNamespaces ( cppfile , sourceDecls ) ; cppfile << "#undef pub\n#undef priv\n" ; } ;

#undef pub
#undef priv
